#include "rsacrt.h"

struct private_key_t {
	// Parameters need for ExpMod operation
	/*	DIGIT_T modulus[MAX_FIXED_DIGITS];
	uint32_t modulus_len;
	DIGIT_T exponent[MAX_FIXED_DIGITS];
	uint32_t int exp_len; */

	// Parameters need for CRT
	DIGIT_T p_crt[MAX_FIXED_DIGITS/2];
	uint32_t p_len;

	DIGIT_T q_crt[MAX_FIXED_DIGITS/2];
	uint32_t q_len;

	DIGIT_T dp_crt[MAX_FIXED_DIGITS/2];
	uint32_t dp_len;

	DIGIT_T dq_crt[MAX_FIXED_DIGITS/2];
	uint32_t dq_len;

	DIGIT_T qInv_crt[MAX_FIXED_DIGITS/2];
	uint32_t qInv_crt_len;
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* Prime p_crt: */
const uint8_t p_crt[] = {
		0xee, 0xcf, 0xae, 0x81, 0xb1, 0xb9, 0xb3, 0xc9, 0x08, 0x81, 0x0b, 0x10, 0xa1, 0xb5, 0x60, 0x01,
		0x99, 0xeb, 0x9f, 0x44, 0xae, 0xf4, 0xfd, 0xa4, 0x93, 0xb8, 0x1a, 0x9e, 0x3d, 0x84, 0xf6, 0x32,
		0x12, 0x4e, 0xf0, 0x23, 0x6e, 0x5d, 0x1e, 0x3b, 0x7e, 0x28, 0xfa, 0xe7, 0xaa, 0x04, 0x0a, 0x2d,
		0x5b, 0x25, 0x21, 0x76, 0x45, 0x9d, 0x1f, 0x39, 0x75, 0x41, 0xba, 0x2a, 0x58, 0xfb, 0x65, 0x99,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* Prime q_crt: */
const uint8_t q_crt[] = {
		0xc9, 0x7f, 0xb1, 0xf0, 0x27, 0xf4, 0x53, 0xf6, 0x34, 0x12, 0x33, 0xea, 0xaa, 0xd1, 0xd9, 0x35,
		0x3f, 0x6c, 0x42, 0xd0, 0x88, 0x66, 0xb1, 0xd0, 0x5a, 0x0f, 0x20, 0x35, 0x02, 0x8b, 0x9d, 0x86,
		0x98, 0x40, 0xb4, 0x16, 0x66, 0xb4, 0x2e, 0x92, 0xea, 0x0d, 0xa3, 0xb4, 0x32, 0x04, 0xb5, 0xcf,
		0xce, 0x33, 0x52, 0x52, 0x4d, 0x04, 0x16, 0xa5, 0xa4, 0x41, 0xe7, 0x00, 0xaf, 0x46, 0x15, 0x03,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* p_crt's CRT exponent dP: */
const uint8_t dp_crt[] = {
		0x54, 0x49, 0x4c, 0xa6, 0x3e, 0xba, 0x03, 0x37, 0xe4, 0xe2, 0x40, 0x23, 0xfc, 0xd6, 0x9a, 0x5a,
		0xeb, 0x07, 0xdd, 0xdc, 0x01, 0x83, 0xa4, 0xd0, 0xac, 0x9b, 0x54, 0xb0, 0x51, 0xf2, 0xb1, 0x3e,
		0xd9, 0x49, 0x09, 0x75, 0xea, 0xb7, 0x74, 0x14, 0xff, 0x59, 0xc1, 0xf7, 0x69, 0x2e, 0x9a, 0x2e,
		0x20, 0x2b, 0x38, 0xfc, 0x91, 0x0a, 0x47, 0x41, 0x74, 0xad, 0xc9, 0x3c, 0x1f, 0x67, 0xc9, 0x81,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* q_crt's CRT exponent dQ: */
const uint8_t dq_crt[] = {
		0x47, 0x1e, 0x02, 0x90, 0xff, 0x0a, 0xf0, 0x75, 0x03, 0x51, 0xb7, 0xf8, 0x78, 0x86, 0x4c, 0xa9,
		0x61, 0xad, 0xbd, 0x3a, 0x8a, 0x7e, 0x99, 0x1c, 0x5c, 0x05, 0x56, 0xa9, 0x4c, 0x31, 0x46, 0xa7,
		0xf9, 0x80, 0x3f, 0x8f, 0x6f, 0x8a, 0xe3, 0x42, 0xe9, 0x31, 0xfd, 0x8a, 0xe4, 0x7a, 0x22, 0x0d,
		0x1b, 0x99, 0xa4, 0x95, 0x84, 0x98, 0x07, 0xfe, 0x39, 0xf9, 0x24, 0x5a, 0x98, 0x36, 0xda, 0x3d,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* CRT coefficient qInv_crt: */
const uint8_t qinv_crt[] = {
		0xb0, 0x6c, 0x4f, 0xda, 0xbb, 0x63, 0x01, 0x19, 0x8d, 0x26, 0x5b, 0xdb, 0xae, 0x94, 0x23, 0xb3,
		0x80, 0xf2, 0x71, 0xf7, 0x34, 0x53, 0x88, 0x50, 0x93, 0x07, 0x7f, 0xcd, 0x39, 0xe2, 0x11, 0x9f,
		0xc9, 0x86, 0x32, 0x15, 0x4f, 0x58, 0x83, 0xb1, 0x67, 0xa9, 0x67, 0xbf, 0x40, 0x2b, 0x4e, 0x9e,
		0x2e, 0x0f, 0x96, 0x56, 0xe6, 0x98, 0xea, 0x36, 0x66, 0xed, 0xfb, 0x25, 0x79, 0x80, 0x39, 0xf7,
};


//For debug purposes= encrypted ciphertext stored in internal FLASH
const uint8_t encrypted_crt[] = {
		0x12, 0x53, 0xe0, 0x4d, 0xc0, 0xa5, 0x39, 0x7b, 0xb4, 0x4a, 0x7a, 0xb8, 0x7e, 0x9b, 0xf2, 0xa0,
		0x39, 0xa3, 0x3d, 0x1e, 0x99, 0x6f, 0xc8, 0x2a, 0x94, 0xcc, 0xd3, 0x00, 0x74, 0xc9, 0x5d, 0xf7,
		0x63, 0x72, 0x20, 0x17, 0x06, 0x9e, 0x52, 0x68, 0xda, 0x5d, 0x1c, 0x0b, 0x4f, 0x87, 0x2c, 0xf6,
		0x53, 0xc1, 0x1d, 0xf8, 0x23, 0x14, 0xa6, 0x79, 0x68, 0xdf, 0xea, 0xe2, 0x8d, 0xef, 0x04, 0xbb,
		0x6d, 0x84, 0xb1, 0xc3, 0x1d, 0x65, 0x4a, 0x19, 0x70, 0xe5, 0x78, 0x3b, 0xd6, 0xeb, 0x96, 0xa0,
		0x24, 0xc2, 0xca, 0x2f, 0x4a, 0x90, 0xfe, 0x9f, 0x2e, 0xf5, 0xc9, 0xc1, 0x40, 0xe5, 0xbb, 0x48,
		0xda, 0x95, 0x36, 0xad, 0x87, 0x00, 0xc8, 0x4f, 0xc9, 0x13, 0x0a, 0xde, 0xa7, 0x4e, 0x55, 0x8d,
		0x51, 0xa7, 0x4d, 0xdf, 0x85, 0xd8, 0xb5, 0x0d, 0xe9, 0x68, 0x38, 0xd6, 0x06, 0x3e, 0x09, 0x55,
};

private_key_t priv_key_crt;			// Private key instance

static DIGIT_T c[MAX_FIXED_DIGITS/2];	// Ciphertext array for Big integer operations
uint8_t c_len_crt;					// Ciphertext length

int charIdx_crt = 0;

static DIGIT_T m[MAX_FIXED_DIGITS/2];  // Cleartext array as result container

// Load big integer from local byte array, MSByte first, int-32 alignment
void load_bytearray_crt(DIGIT_T * out, const uint8_t * in, uint16_t len) {
	volatile uint32_t n_32b_int, n_left, tmp = 0;
	int i = 0;

	mpSetZero(out, MAX_FIXED_DIGITS/2);

	n_32b_int = len / 4;
	n_left = len & 0x3;

	if( n_left > 0) {
		while( i < n_left ) {
			tmp <<= 8;
			tmp |= *in;
			in ++;
			i ++;
			len --;
		}
		out[n_32b_int] = tmp;
	}

	i = 0;
	tmp = 0;
	while (len > 0) {
		tmp <<= 8;
		tmp |= *in;
		i ++;
		in ++;
		len --;
		if ( i == 4 ) {
			i = 0;
			out[n_32b_int-1] = tmp;
			n_32b_int --;
		}
	}

}

void input_cipher_text_crt(uint32_t len) {
	volatile uint32_t n_32b_int, n_left, tmp = 0;
	uint8_t rxbyte;
	int i = 0;
    charIdx_crt = 0;
	c_len_crt = (len + 3) / sizeof(uint32_t);

	mpSetZero(c, MAX_FIXED_DIGITS/2);

	n_32b_int = len / 4;
	n_left = len & 0x3;

	if( n_left > 0) {
		while( i < n_left ) {
			tmp <<= 8;
            readByteFromInputBuffer(&rxbyte, &charIdx_crt);
			tmp = tmp|rxbyte;
			i ++;
			len --;
		}
		c[n_32b_int] = tmp;
	}

	i = 0;
	tmp = 0;
	while (len > 0) {
		tmp <<= 8;
        readByteFromInputBuffer(&rxbyte, &charIdx_crt);
		tmp = tmp|rxbyte;
		i ++;
		len --;
		if ( i == 4 ) {
			i = 0;
			c[n_32b_int-1] = tmp;
			n_32b_int --;
		}
	}
}

void send_clear_text_crt() {
	int i;

	for( i = (MAX_FIXED_DIGITS/2) - 1; i > -1; i --) {
		if( m[i] != 0) {
			send_char(((i+1)*4) >> 8 & 0xff);
			send_char(((i+1)*4) >> 0 & 0xff);
			break;
		}
	}

	// If the result is 0, send 0x00, 0x00, 0x00, 0x00 over serial
	if( i == -1) {
		send_char(0x00);
		send_char(0x00);
		send_char(0x00);
		send_char(0x00);
	} else {
		//Else send the rest of integers over serial, with order of Bit[31:24] -> Bit[23:16] -> Bit[15:8] -> Bit[7:0]
		for( ; i > -1; i --) {
			send_char(m[i] >> 24 & 0xff);
			send_char(m[i] >> 16 & 0xff);
			send_char(m[i] >>  8 & 0xff);
			send_char(m[i] >>  0 & 0xff);
		}
	}
}

// Load CRT related parameters
// p_crt  = Prime p_crt
// q_crt  = Prime q_crt
// dp_crt = p_crt's CRT exponent dP
// dq_crt = q_crt's CRT exponent dQ
// qInv = CRT coefficient qInv
void rsa_crt_init() {
	load_bytearray_crt(priv_key_crt.p_crt, p_crt, sizeof(p_crt));
	priv_key_crt.p_len = (sizeof(p_crt) + 3) / sizeof(uint32_t);		// Rounded-up size of array "p_crt"

	load_bytearray_crt(priv_key_crt.q_crt, q_crt, sizeof(q_crt));
	priv_key_crt.q_len = (sizeof(q_crt) + 3) / sizeof(uint32_t);

	load_bytearray_crt(priv_key_crt.dp_crt, dp_crt, sizeof(dp_crt));
	priv_key_crt.dp_len = (sizeof(dp_crt) + 3) / sizeof(uint32_t);

	load_bytearray_crt(priv_key_crt.dq_crt, dq_crt, sizeof(dq_crt));
	priv_key_crt.dp_len = (sizeof(dp_crt) + 3) / sizeof(uint32_t);

	load_bytearray_crt(priv_key_crt.qInv_crt, qinv_crt, sizeof(qinv_crt));
	priv_key_crt.dp_len = (sizeof(dp_crt) + 3) / sizeof(uint32_t);

	load_bytearray_crt(c, encrypted_crt, sizeof(encrypted_crt));
	c_len_crt = (sizeof(encrypted_crt) + 3) / sizeof(uint32_t);
}

// Find the maxmimum number of digits among all parameters
size_t max_digits_of_input_crt() {
	size_t max_len;

	max_len = max(priv_key_crt.p_len, priv_key_crt.q_len);
	max_len = max(max_len, priv_key_crt.dp_len);
	max_len = max(max_len, priv_key_crt.dq_len);
	max_len = max(max_len, priv_key_crt.qInv_crt_len);
	max_len = max(max_len, c_len_crt);

	return max_len;

}

void rsa_crt_decrypt(){
	DIGIT_T m1[MAX_FIXED_DIGITS/2];
	DIGIT_T m2[MAX_FIXED_DIGITS/2];
	DIGIT_T h[MAX_FIXED_DIGITS/2];
	DIGIT_T tmp[MAX_FIXED_DIGITS];
	size_t max_len;

	// Get the maximum number of digits from p_crt, q_crt, dp_crt, dq_crt, qInv, cipher text
	max_len = max_digits_of_input_crt();

	// Initialize M to 0
	mpSetZero(m, MAX_FIXED_DIGITS/2);

	// Trigger goes high on trigger pin (PC2) and PH2
	GPIOC->BSRRL = GPIO_Pin_2;
	GPIOH->BSRRL = GPIO_Pin_2;

	// m1 = c^dP mod p_crt (Exponentiation with dP)
	mpModExpL2R(m1, c, priv_key_crt.dp_crt, priv_key_crt.p_crt, max_len);

	//Trigger keeps HIGH for trigger PC2, off for PH2, on for PH3
	GPIOH->BSRRH = GPIO_Pin_2;
	GPIOH->BSRRL = GPIO_Pin_3;

	// m2 = c^dQ mod q_crt (Exponentiation with dQ)
	mpModExpL2R(m2, c, priv_key_crt.dq_crt, priv_key_crt.q_crt, max_len);

	//Triggers goes down on trigger pin and also on PH3
	GPIOC->BSRRH = GPIO_Pin_2;
	GPIOH->BSRRH = GPIO_Pin_3;

	// tmp = m1 + p_crt - m2 TODO: What if m2 > m1 ????
	mpAdd(tmp, m1, priv_key_crt.p_crt, max_len);
	mpSubtract(tmp, tmp, m2, max_len);

	// h = tmp * qInv mod p_crt
	mpModMult(h, tmp, priv_key_crt.qInv_crt, priv_key_crt.p_crt, max_len);

	// tmp = q_crt `* h
	mpMultiply(tmp, priv_key_crt.q_crt, h, max_len);

	// clear_text = tmp + m2
	mpAdd(m, m2, tmp, max_len);



}

void readFromCharArray_crt(uint8_t *ch){
	*ch=encrypted_crt[charIdx_crt];
	charIdx_crt++;
}
