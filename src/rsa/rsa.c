#include "rsa.h"

struct private_key_t {

	// Parameters need for CRT
	DIGIT_T p[MAX_FIXED_DIGITS/2];
	uint32_t p_len;

	DIGIT_T q[MAX_FIXED_DIGITS/2];
	uint32_t q_len;

	DIGIT_T dp[MAX_FIXED_DIGITS/2];
	uint32_t dp_len;

	DIGIT_T dq[MAX_FIXED_DIGITS/2];
	uint32_t dq_len;

	DIGIT_T qInv[MAX_FIXED_DIGITS/2];
	uint32_t qInv_len;
};

struct rsa_sfm_private_key_t {

	DIGIT_T D[MAX_FIXED_DIGITS/2];
	uint32_t D_len;

	DIGIT_T E[MAX_FIXED_DIGITS/2];
	uint32_t E_len;

	DIGIT_T N[MAX_FIXED_DIGITS/2];
	uint32_t N_len;

	DIGIT_T phiN[MAX_FIXED_DIGITS/2];
	uint32_t phiN_len;

	DIGIT_T R[MAX_FIXED_DIGITS/2];
	uint32_t R_len;

	DIGIT_T invN;
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* Prime p: */
const uint8_t p[] = {
		0xee, 0xcf, 0xae, 0x81, 0xb1, 0xb9, 0xb3, 0xc9, 0x08, 0x81, 0x0b, 0x10, 0xa1, 0xb5, 0x60, 0x01,
		0x99, 0xeb, 0x9f, 0x44, 0xae, 0xf4, 0xfd, 0xa4, 0x93, 0xb8, 0x1a, 0x9e, 0x3d, 0x84, 0xf6, 0x32,
		0x12, 0x4e, 0xf0, 0x23, 0x6e, 0x5d, 0x1e, 0x3b, 0x7e, 0x28, 0xfa, 0xe7, 0xaa, 0x04, 0x0a, 0x2d,
		0x5b, 0x25, 0x21, 0x76, 0x45, 0x9d, 0x1f, 0x39, 0x75, 0x41, 0xba, 0x2a, 0x58, 0xfb, 0x65, 0x99,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* Prime q: */
const uint8_t q[] = {
		0xc9, 0x7f, 0xb1, 0xf0, 0x27, 0xf4, 0x53, 0xf6, 0x34, 0x12, 0x33, 0xea, 0xaa, 0xd1, 0xd9, 0x35,
		0x3f, 0x6c, 0x42, 0xd0, 0x88, 0x66, 0xb1, 0xd0, 0x5a, 0x0f, 0x20, 0x35, 0x02, 0x8b, 0x9d, 0x86,
		0x98, 0x40, 0xb4, 0x16, 0x66, 0xb4, 0x2e, 0x92, 0xea, 0x0d, 0xa3, 0xb4, 0x32, 0x04, 0xb5, 0xcf,
		0xce, 0x33, 0x52, 0x52, 0x4d, 0x04, 0x16, 0xa5, 0xa4, 0x41, 0xe7, 0x00, 0xaf, 0x46, 0x15, 0x03,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* p's CRT exponent dP: */
const uint8_t dp[] = {
		0x54, 0x49, 0x4c, 0xa6, 0x3e, 0xba, 0x03, 0x37, 0xe4, 0xe2, 0x40, 0x23, 0xfc, 0xd6, 0x9a, 0x5a,
		0xeb, 0x07, 0xdd, 0xdc, 0x01, 0x83, 0xa4, 0xd0, 0xac, 0x9b, 0x54, 0xb0, 0x51, 0xf2, 0xb1, 0x3e,
		0xd9, 0x49, 0x09, 0x75, 0xea, 0xb7, 0x74, 0x14, 0xff, 0x59, 0xc1, 0xf7, 0x69, 0x2e, 0x9a, 0x2e,
		0x20, 0x2b, 0x38, 0xfc, 0x91, 0x0a, 0x47, 0x41, 0x74, 0xad, 0xc9, 0x3c, 0x1f, 0x67, 0xc9, 0x81,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* q's CRT exponent dQ: */
const uint8_t dq[] = {
		0x47, 0x1e, 0x02, 0x90, 0xff, 0x0a, 0xf0, 0x75, 0x03, 0x51, 0xb7, 0xf8, 0x78, 0x86, 0x4c, 0xa9,
		0x61, 0xad, 0xbd, 0x3a, 0x8a, 0x7e, 0x99, 0x1c, 0x5c, 0x05, 0x56, 0xa9, 0x4c, 0x31, 0x46, 0xa7,
		0xf9, 0x80, 0x3f, 0x8f, 0x6f, 0x8a, 0xe3, 0x42, 0xe9, 0x31, 0xfd, 0x8a, 0xe4, 0x7a, 0x22, 0x0d,
		0x1b, 0x99, 0xa4, 0x95, 0x84, 0x98, 0x07, 0xfe, 0x39, 0xf9, 0x24, 0x5a, 0x98, 0x36, 0xda, 0x3d,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* CRT coefficient qInv: */
const uint8_t qinv[] = {
		0xb0, 0x6c, 0x4f, 0xda, 0xbb, 0x63, 0x01, 0x19, 0x8d, 0x26, 0x5b, 0xdb, 0xae, 0x94, 0x23, 0xb3,
		0x80, 0xf2, 0x71, 0xf7, 0x34, 0x53, 0x88, 0x50, 0x93, 0x07, 0x7f, 0xcd, 0x39, 0xe2, 0x11, 0x9f,
		0xc9, 0x86, 0x32, 0x15, 0x4f, 0x58, 0x83, 0xb1, 0x67, 0xa9, 0x67, 0xbf, 0x40, 0x2b, 0x4e, 0x9e,
		0x2e, 0x0f, 0x96, 0x56, 0xe6, 0x98, 0xea, 0x36, 0x66, 0xed, 0xfb, 0x25, 0x79, 0x80, 0x39, 0xf7,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* Squared of Montgomery Constant R=2^512: R^2 mod p */
const uint8_t Rp[] = {
		0x81, 0x3A, 0x71, 0x00, 0x36, 0x6F, 0xDE, 0x65, 0xD0, 0xAC, 0x52, 0xA0, 0xD9, 0xB3, 0x6B, 0x21,
		0x2F, 0xCF, 0x64, 0xBC, 0x3F, 0x73, 0xC2, 0xCD, 0xD6, 0x17, 0xE3, 0xFF, 0x65, 0xBD, 0xAC, 0x23,
		0xCB, 0xBD, 0x68, 0xC0, 0x04, 0xF8, 0xE2, 0xB8, 0x8A, 0x79, 0x6E, 0xF1, 0x49, 0x05, 0xA3, 0xA2,
		0x24, 0x62, 0x3A, 0x3B, 0xE4, 0xC9, 0xC4, 0x84, 0x44, 0xFD, 0xFF, 0x3E, 0x27, 0x09, 0x4C, 0x76,
};

// MSByte First, int32 aligned
// Stored in FLASH MEM
/* Squared of Montgomery Constant R=2^512: R^2 mod q */
const uint8_t Rq[] = {
		0x44, 0x9F, 0xE0, 0x2E, 0x82, 0x46, 0x26, 0x61, 0x76, 0x29, 0x8B, 0x2A, 0x4E, 0x09, 0xFD, 0x9C,
		0xB4, 0xC9, 0x90, 0xFF, 0x36, 0x42, 0x1D, 0x33, 0x19, 0x6C, 0x33, 0x84, 0xB1, 0x1B, 0x99, 0xE2,
		0x63, 0x72, 0xDC, 0x76, 0x80, 0x2A, 0x31, 0xA4, 0x7B, 0xC2, 0x7F, 0xC2, 0x57, 0xC1, 0x87, 0x83,
		0xE4, 0xDC, 0xBF, 0x2C, 0x46, 0x38, 0x36, 0xC1, 0xD2, 0x36, 0x2D, 0x32, 0x70, 0xAE, 0xB2, 0x0D,
};

const uint32_t invp = 0x418DE157;
const uint32_t invq = 0x18DB0255;

//For debug purposes= encrypted ciphertext stored in internal FLASH
const uint8_t encrypted[] = {
		0x12, 0x53, 0xe0, 0x4d, 0xc0, 0xa5, 0x39, 0x7b, 0xb4, 0x4a, 0x7a, 0xb8, 0x7e, 0x9b, 0xf2, 0xa0,
		0x39, 0xa3, 0x3d, 0x1e, 0x99, 0x6f, 0xc8, 0x2a, 0x94, 0xcc, 0xd3, 0x00, 0x74, 0xc9, 0x5d, 0xf7,
		0x63, 0x72, 0x20, 0x17, 0x06, 0x9e, 0x52, 0x68, 0xda, 0x5d, 0x1c, 0x0b, 0x4f, 0x87, 0x2c, 0xf6,
		0x53, 0xc1, 0x1d, 0xf8, 0x23, 0x14, 0xa6, 0x79, 0x68, 0xdf, 0xea, 0xe2, 0x8d, 0xef, 0x04, 0xbb,
		0x6d, 0x84, 0xb1, 0xc3, 0x1d, 0x65, 0x4a, 0x19, 0x70, 0xe5, 0x78, 0x3b, 0xd6, 0xeb, 0x96, 0xa0,
		0x24, 0xc2, 0xca, 0x2f, 0x4a, 0x90, 0xfe, 0x9f, 0x2e, 0xf5, 0xc9, 0xc1, 0x40, 0xe5, 0xbb, 0x48,
		0xda, 0x95, 0x36, 0xad, 0x87, 0x00, 0xc8, 0x4f, 0xc9, 0x13, 0x0a, 0xde, 0xa7, 0x4e, 0x55, 0x8d,
		0x51, 0xa7, 0x4d, 0xdf, 0x85, 0xd8, 0xb5, 0x0d, 0xe9, 0x68, 0x38, 0xd6, 0x06, 0x3e, 0x09, 0x55,
};

/*********************************** SFM RSA **********************************************************/
const uint8_t N[] = {
		/*0xA0, 0x54, 0x6C, 0x2A, 0x22, 0x1B, 0x97, 0x85, 0x92, 0x6F, 0xEA, 0x42, 0xC9, 0x4B, 0x2D, 0x9D,
		0xC7, 0xAE, 0x1A, 0x73, 0xB4, 0x91, 0xB4, 0xEC, 0x9E, 0x1E, 0xB1, 0x95, 0x5E, 0x8F, 0x0D, 0x4B,
		0xBD, 0xDB, 0xF8, 0x0B, 0x89, 0x54, 0x89, 0x60, 0xAE, 0x9E, 0x4A, 0xBD, 0x7F, 0x3F, 0xAF, 0x17,
		0x96, 0x4D, 0xE8, 0xE2, 0x32, 0x3E, 0xC1, 0x8F, 0x8B, 0xC6, 0x0E, 0x72, 0x25, 0xBE, 0x6F, 0xF1,*/
		0xED, 0xDE, 0x30, 0xA3, 0x52, 0xE6, 0x62, 0x56, 0xE5, 0x93, 0xEF, 0xBC, 0xA5, 0x4E, 0x20, 0x85,
		0x34, 0x59, 0x53, 0x4B, 0x71, 0xAF, 0xAB, 0x0F, 0x05, 0x8A, 0x2C, 0xA5, 0x82, 0xCE, 0x15, 0x61,
		0x7D, 0x95, 0x92, 0xC8, 0x7D, 0xF7, 0x20, 0xC6, 0x74, 0x41, 0x66, 0x52, 0xC1, 0xCF, 0x90, 0xF5,
		0xD8, 0x98, 0xDD, 0x38, 0x39, 0x68, 0xCB, 0xD3, 0x3D, 0xE9, 0xF1, 0x1C, 0x71, 0xF5, 0xD4, 0x71,
};//just composite modulus

const uint8_t phiN[] = {
		/*0xA0, 0x54, 0x6C, 0x2A, 0x22, 0x1B, 0x97, 0x85, 0x92, 0x6F, 0xEA, 0x42, 0xC9, 0x4B, 0x2D, 0x9D,
		0xC7, 0xAE, 0x1A, 0x73, 0xB4, 0x91, 0xB4, 0xEC, 0x9E, 0x1E, 0xB1, 0x95, 0x5E, 0x8F, 0x0D, 0x4A,
		0x1F, 0xB3, 0x98, 0xB1, 0x4B, 0xAB, 0x9E, 0xF2, 0xAE, 0x76, 0x54, 0x7D, 0xF3, 0x58, 0x79, 0x61,
		0x8C, 0xC7, 0x23, 0x13, 0x93, 0x20, 0x96, 0x65, 0xA1, 0x0C, 0x1B, 0xF6, 0x17, 0x47, 0xE3, 0xF4,*/
		0xED, 0xDE, 0x30, 0xA3, 0x52, 0xE6, 0x62, 0x56, 0xE5, 0x93, 0xEF, 0xBC, 0xA5, 0x4E, 0x20, 0x85,
		0x34, 0x59, 0x53, 0x4B, 0x71, 0xAF, 0xAB, 0x0F, 0x05, 0x8A, 0x2C, 0xA5, 0x82, 0xCE, 0x15, 0x5F,
		0x90, 0x0C, 0x44, 0x81, 0x02, 0x17, 0x66, 0xFF, 0xDB, 0xB5, 0xB6, 0xC8, 0x73, 0x8B, 0x7C, 0x64,
		0x42, 0x4A, 0x77, 0xEA, 0x38, 0xA0, 0xA5, 0xD8, 0x76, 0xD0, 0x05, 0x24, 0x35, 0xEC, 0xD1, 0x40,
};

const uint8_t D[] = {
		/*0x13, 0xAE, 0x69, 0x5C, 0xBE, 0xB5, 0x1E, 0x63, 0x92, 0x37, 0x54, 0xCD, 0x80, 0x02, 0x4F, 0x86,
		0x37, 0xD5, 0xE2, 0x7F, 0x63, 0xA2, 0x23, 0x50, 0x8C, 0x94, 0x7D, 0xFE, 0x35, 0x0E, 0x60, 0x76,
		0x41, 0xEF, 0xFD, 0x05, 0x7E, 0xA1, 0x81, 0xB0, 0x8E, 0xC4, 0x0D, 0xD9, 0x2C, 0x3F, 0x27, 0x1F,
		0x57, 0x75, 0xB6, 0x93, 0x97, 0x92, 0xFF, 0x83, 0x58, 0x42, 0xB1, 0x48, 0x03, 0x51, 0x9A, 0xE5,*/
		0xA9, 0x93, 0x29, 0xF7, 0x75, 0x45, 0x1A, 0xBC, 0x3A, 0x44, 0xA1, 0xB7, 0x49, 0xDD, 0x8D, 0x9F,
		0x88, 0xB7, 0x59, 0x83, 0x42, 0x53, 0xEA, 0xCD, 0xF5, 0xB4, 0x10, 0xAA, 0x19, 0xBB, 0x53, 0x4F,
		0x62, 0x40, 0xEC, 0xA1, 0x4F, 0xDD, 0x61, 0x27, 0x6B, 0xF9, 0x7A, 0x8A, 0x22, 0x9D, 0x41, 0x1B,
		0xB4, 0x8A, 0xA4, 0x3C, 0x4D, 0x0C, 0x71, 0xCF, 0x04, 0xBC, 0xBD, 0xBD, 0x97, 0xD7, 0xF1, 0x41,
};

const uint8_t E_SFM[] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
};

const uint8_t R[] = {
		/*0x44, 0x35, 0xBB, 0x9F, 0xDF, 0x88, 0xF5, 0xAE, 0xB8, 0xDC, 0x2C, 0x7C, 0xC5, 0xD5, 0xCD, 0xF5,
		0xF6, 0xD9, 0x34, 0x4E, 0x79, 0xBF, 0xCB, 0x8B, 0x05, 0xF3, 0x88, 0x9B, 0x37, 0xEC, 0xB4, 0x75,
		0x17, 0xCC, 0x73, 0xF7, 0xE4, 0xE5, 0x0A, 0xF1, 0x24, 0xEA, 0xC1, 0x5D, 0x15, 0xE5, 0xC0, 0xBB,
		0xFF, 0x2A, 0x03, 0x90, 0x46, 0x8A, 0xBC, 0xEC, 0xAF, 0x3B, 0x5E, 0x8C, 0x4A, 0x88, 0x5C, 0x30,*/
		0xC1, 0x73, 0x51, 0x24, 0xDF, 0xF0, 0xCD, 0x59, 0xAA, 0x63, 0xA4, 0xBD, 0xB8, 0x02, 0xB1, 0x53,
		0xF4, 0xAD, 0xCB, 0xA5, 0x9C, 0xD3, 0x49, 0x7E, 0x88, 0x2A, 0x9D, 0xDC, 0x76, 0x77, 0xEE, 0x4C,
		0x2C, 0x25, 0x71, 0xB7, 0x75, 0x29, 0xCA, 0x35, 0x75, 0x7D, 0x2A, 0xBC, 0xE1, 0x59, 0x85, 0x21,
		0xEA, 0x96, 0xE6, 0x93, 0x40, 0xF1, 0x86, 0xF3, 0x7C, 0xB7, 0x33, 0x29, 0x44, 0xD3, 0xE5, 0x9C,
};// R = (2^512)^2 mod N

//const uint32_t invN = 0x32CB5EEF;
const uint32_t invN = 0x8A2C936F;
//N * invN = -1 mod 2^{4*8}

//For debug purposes= encrypted ciphertext stored in internal FLASH
const uint8_t encrypted512[] = {
		0x4A, 0x11, 0x16, 0x49, 0x42, 0x83, 0xD9, 0x89, 0x5D, 0xB3, 0x8B, 0xA5, 0x06, 0xC5, 0x16, 0x4F,
		0xAB, 0x77, 0xFB, 0xB5, 0x14, 0xB2, 0xCD, 0x5D, 0x7E, 0x8E, 0x66, 0x49, 0x0A, 0x0C, 0x88, 0x36,
		0x14, 0xA5, 0xE2, 0xC8, 0xB0, 0x99, 0x4B, 0xF3, 0xE0, 0xD2, 0xF6, 0xB6, 0x28, 0xB7, 0x28, 0x09,
		0x5E, 0xCD, 0xA8, 0xCB, 0xA5, 0x71, 0x12, 0x14, 0x7F, 0xA1, 0x04, 0x95, 0xAD, 0x7E, 0x81, 0x8A,
};


private_key_t priv_key;			// Private key instance
rsa_sfm_private_key_t rsa_sfm_priv_key;			// Private key instance

int charIdx = 0;

static DIGIT_T c[MAX_FIXED_DIGITS/2];	// Ciphertext array for Big integer operations
uint8_t c_len;					// Ciphertext length

static DIGIT_T m[MAX_FIXED_DIGITS/2];  // Cleartext array as result container

static DIGIT_T externalD [16];  // variable key

static DIGIT_T externalN [16];  // variable key

static key_management_method_t keyGenerationMethod;
static rsa_sfm_implementation_type_t implementationType;

static DIGIT_T rand_between(DIGIT_T lower, DIGIT_T upper);
static DIGIT_T rand_between(DIGIT_T lower, DIGIT_T upper)
/* Returns a single pseudo-random digit between lower and upper.
   Uses rand(). Assumes srand() already called. */
{
	DIGIT_T d, range;
	unsigned char *bp;
	int i, nbits;
	DIGIT_T mask;

	if (upper <= lower) return lower;
	range = upper - lower;

	do
	{
		/* Generate a random DIGIT byte-by-byte using rand() */
		bp = (unsigned char *)&d;
		for (i = 0; i < sizeof(DIGIT_T); i++)
		{
			bp[i] = (unsigned char)(rand() & 0xFF);
		}

		/* Trim to next highest bit above required range */
		mask = HIBITMASK;
		for (nbits = BITS_PER_DIGIT; nbits > 0; nbits--, mask >>= 1)
		{
			if (range & mask)
				break;
		}
		if (nbits < BITS_PER_DIGIT)
		{
			mask <<= 1;
			mask--;
		}
		else
			mask = MAX_DIGIT;

		d &= mask;

	} while (d > range);

	return (lower + d);
}

// Load big integer from local byte array, MSByte first, int-32 alignment
void load_bytearray(DIGIT_T * out, const uint8_t * in, uint16_t len) {
	volatile uint32_t n_32b_int, n_left, tmp = 0;
	int i = 0;

	mpSetZero(out, MAX_FIXED_DIGITS/2);

	n_32b_int = len / 4;
	n_left = len & 0x3;

	if( n_left > 0) {
		while( i < n_left ) {
			tmp <<= 8;
			tmp |= *in;
			in ++;
			i ++;
			len --;
		}
		out[n_32b_int] = tmp;
	}

	i = 0;
	tmp = 0;
	while (len > 0) {
		tmp <<= 8;
		tmp |= *in;
		i ++;
		in ++;
		len --;
		if ( i == 4 ) {
			i = 0;
			out[n_32b_int-1] = tmp;
			n_32b_int --;
		}
	}

}

void input_cipher_text(uint32_t len) {
	volatile uint32_t n_32b_int, n_left, tmp;//, n_32b_idx = 0;
	uint8_t rxbyte;
	const uint32_t orglen = len;
	int i = 0;
    charIdx = 0;
	c_len = (len + 3) / sizeof(uint32_t);

	mpSetZero(c, MAX_FIXED_DIGITS/2);

	n_32b_int = len / 4;
	n_left = len & 0x3;

	if( n_left > 0) {
		while( i < n_left ) {
			tmp <<= 8;
			readByteFromInputBuffer(&rxbyte, &charIdx);
			tmp = tmp|rxbyte;
			i ++;
			len --;
		}
		c[n_32b_int] = tmp;
	}

	i = 0;
	tmp = 0;
	while (len > 0) {
		tmp <<= 8;
		readByteFromInputBuffer(&rxbyte, &charIdx);
		tmp = tmp|rxbyte;
		i ++;
		len --;
		if ( i == 4 ) {
			i = 0;
			c[n_32b_int-1] = tmp;
			n_32b_int --;
		}
	}
}

void send_clear_text() {
	int i;

	for( i = (MAX_FIXED_DIGITS/2) - 1; i > -1; i --) {
		if( m[i] != 0) {
			send_char(((i+1)*4) >> 8 & 0xff);
			send_char(((i+1)*4) >> 0 & 0xff);
			break;
		}
	}

	// If the result is 0, send 0xFF, 0xFF, 0xFF, 0xFF over serial
	if( i == -1) {
		send_char(0xFF);
		send_char(0xFF);
		send_char(0xFF);
		send_char(0xFF);
	} else {
		//Else send the rest of integers over serial, with order of Bit[31:24] -> Bit[23:16] -> Bit[15:8] -> Bit[7:0]
		for( ; i > -1; i --) {
			send_char(m[i] >> 24 & 0xff);
			send_char(m[i] >> 16 & 0xff);
			send_char(m[i] >>  8 & 0xff);
			send_char(m[i] >>  0 & 0xff);
		}
	}
}

// Load RSA SFM related parameters
void rsa_sfm_init() {
	load_bytearray(rsa_sfm_priv_key.D, D, sizeof(D));
	rsa_sfm_priv_key.D_len = (sizeof(D) + 3) / sizeof(uint32_t);

	load_bytearray(rsa_sfm_priv_key.E, E_SFM, sizeof(E_SFM));
	rsa_sfm_priv_key.E_len = (sizeof(E_SFM) + 3) / sizeof(uint32_t);		// Rounded-up size of array "p"

	load_bytearray(rsa_sfm_priv_key.N, N, sizeof(N));
	rsa_sfm_priv_key.N_len = (sizeof(N) + 3) / sizeof(uint32_t);

	load_bytearray(rsa_sfm_priv_key.phiN, phiN, sizeof(phiN));
	rsa_sfm_priv_key.phiN_len = (sizeof(phiN) + 3) / sizeof(uint32_t);

	load_bytearray(rsa_sfm_priv_key.R, R, sizeof(R));
	rsa_sfm_priv_key.R_len = (sizeof(R) + 3) / sizeof(uint32_t);

	rsa_sfm_priv_key.invN = invN;

	load_bytearray(c, encrypted512, sizeof(encrypted512));
	c_len = (sizeof(encrypted512) + 3) / sizeof(uint32_t);

	keyGenerationMethod = KEY_HARDCODED_ON_TARGET;
	implementationType = RSA_SFM_IMPLEMENTATION_SIMPLE_SQM;
}

// Load CRT related parameters
// p  = Prime p
// q  = Prime q
// dp = p's CRT exponent dP
// dq = q's CRT exponent dQ
// qInv = CRT coefficient qInv
void rsa_init() {
	load_bytearray(priv_key.p, p, sizeof(p));
	priv_key.p_len = (sizeof(p) + 3) / sizeof(uint32_t);		// Rounded-up size of array "p"

	load_bytearray(priv_key.q, q, sizeof(q));
	priv_key.q_len = (sizeof(q) + 3) / sizeof(uint32_t);

	load_bytearray(priv_key.dp, dp, sizeof(dp));
	priv_key.dp_len = (sizeof(dp) + 3) / sizeof(uint32_t);

	load_bytearray(priv_key.dq, dq, sizeof(dq));
	priv_key.dp_len = (sizeof(dp) + 3) / sizeof(uint32_t);

	load_bytearray(priv_key.qInv, qinv, sizeof(qinv));
	priv_key.dp_len = (sizeof(dp) + 3) / sizeof(uint32_t);

	load_bytearray(c, encrypted, sizeof(encrypted));
	c_len = (sizeof(encrypted) + 3) / sizeof(uint32_t);
}

// Find the maxmimum number of digits among all parameters for RSA-CRT
size_t max_digits_of_input() {
	size_t max_len;

	max_len = max(priv_key.p_len, priv_key.q_len);
	max_len = max(max_len, priv_key.dp_len);
	max_len = max(max_len, priv_key.dq_len);
	max_len = max(max_len, priv_key.qInv_len);
	max_len = max(max_len, c_len);

	return max_len;

}
// Find the maxmimum number of digits among all parameters
size_t max_digits_of_input_sfm() {
	size_t max_len;

	max_len = max(rsa_sfm_priv_key.D_len, rsa_sfm_priv_key.N_len);
	max_len = max(max_len, rsa_sfm_priv_key.D_len);
	max_len = max(max_len, rsa_sfm_priv_key.E_len);
	max_len = max(max_len, rsa_sfm_priv_key.N_len);
	max_len = max(max_len, rsa_sfm_priv_key.phiN_len);
	max_len = max(max_len, rsa_sfm_priv_key.R_len);
	max_len = max(max_len, c_len);

	return max_len;

}

void rsa_sfm_decrypt(){
	size_t max_len;
	DIGIT_T ciphertext[16];
	DIGIT_T plaintext[16];
	DIGIT_T d_rand[17];
	DIGIT_T d_temp[17];
	DIGIT_T e_temp[17];
	DIGIT_T phi_temp[17];
	DIGIT_T random32;
	int i;

	// Get the maximum number of digits from ciphertext
	max_len = max_digits_of_input_sfm();

	// Initialize M to 0
	mpSetZero(m, max_len);

	for(i=0;i<max_len;i++){
		e_temp[i] = rsa_sfm_priv_key.E[i];
	}
	e_temp[max_len] = 0; //Put zeros in the MSbs

	//We do an encryption first in order to get the values right; typically this would be unnecessary
	mpModExp(ciphertext, c, e_temp, rsa_sfm_priv_key.N, rsa_sfm_priv_key.R, rsa_sfm_priv_key.invN, max_len, implementationType);

	//Commented out countermeasures: message blinding, exponent blinding

	//exponent blinding
	//D' = D + r.phi(N)

	for(i=0;i<max_len;i++){
		if (keyGenerationMethod == KEY_PASSED_TO_THE_TARGET) {
			d_temp[i] = externalD[i];
		}
		else {
			d_temp[i] = rsa_sfm_priv_key.D[i];
		}

		phi_temp[i] = rsa_sfm_priv_key.phiN[i];
	}
	d_temp[max_len] = 0; //Put zeros in the MSbs
	phi_temp[max_len] = 0; //Put zeros in the MSbs

	/* The following code is not tested since this key generation method is currently not used.
	 * However, the code is left here for possible use in the future.
	 */
	if (keyGenerationMethod == RANDOM_MASKING_ON_TARGET) {
		for(i = 0;i <= max_len; i++){
			d_rand[i] = 0;
		}

		random32 = rand_between(0x00000000, 0x0000FFFF); //generate a pseudo-random number of 32 bits
		mpMultiplyByDigit(d_rand, phi_temp, random32, max_len+1); //d_rand = r * phi(N)
		mpAdd(d_temp,d_rand,d_temp,max_len+1); //d_temp = D + d_rand
	}

	GPIOC->BSRRL = GPIO_Pin_2; //Trigger on
	disable_clocks();

	// decrypt m1 = c^(D+r.phi(N)) mod N (modular exponentiation)
	mpModExp(plaintext, ciphertext, d_temp, rsa_sfm_priv_key.N, rsa_sfm_priv_key.R, rsa_sfm_priv_key.invN, max_len, implementationType);

	for(i=0;i<max_len;i++){
		m[i] = plaintext[i];
	}
	enable_clocks();
	GPIOC->BSRRH = GPIO_Pin_2; //Trigger off
}


void rsa_decrypt(){
	DIGIT_T m1[MAX_FIXED_DIGITS/2];
	DIGIT_T m2[MAX_FIXED_DIGITS/2];
	DIGIT_T h[MAX_FIXED_DIGITS/2];
	DIGIT_T tmp[MAX_FIXED_DIGITS];
	size_t max_len;

	// Get the maximum number of digits from p, q, dp, dq, qInv, cipher text
	max_len = max_digits_of_input();

	// Initialize M to 0
	mpSetZero(m, MAX_FIXED_DIGITS/2);

	// Trigger goes high on trigger pin (PC2) and PH2
	GPIOC->BSRRL = GPIO_Pin_2;
	GPIOH->BSRRL = GPIO_Pin_2;

	// m1 = c^dP mod p (Exponentiation with dP)
	mpModExpL2R(m1, c, priv_key.dp, priv_key.p, max_len);

	//Trigger keeps HIGH for trigger PC2, off for PH2, on for PH3
	GPIOH->BSRRH = GPIO_Pin_2;
	GPIOH->BSRRL = GPIO_Pin_3;

	// m2 = c^dQ mod q (Exponentiation with dQ)
	mpModExpL2R(m2, c, priv_key.dq, priv_key.q, max_len);

	//Triggers goes down on trigger pin and also on PH3
	GPIOC->BSRRH = GPIO_Pin_2;
	GPIOH->BSRRH = GPIO_Pin_3;

	// tmp = m1 + p - m2 TODO: What if m2 > m1 ????
	mpAdd(tmp, m1, priv_key.p, max_len);
	mpSubtract(tmp, tmp, m2, max_len);

	// h = tmp * qInv mod p
	mpModMult(h, tmp, priv_key.qInv, priv_key.p, max_len);

	// tmp = q * h
	mpMultiply(tmp, priv_key.q, h, max_len);

	// clear_text = tmp + m2
	mpAdd(m, m2, tmp, max_len);



}

void readFromCharArray(uint8_t *ch){
	*ch=encrypted[charIdx];
	charIdx++;
}

void input_external_exponent(uint32_t len) {
	volatile uint32_t n_32b_int = len / 4;
	volatile uint32_t n_left = len & 0x3;
	volatile uint32_t tmp = 0;
	int i = 0;
	uint8_t rxbyte;

	if( n_left > 0) {
		while( i < n_left ) {
			tmp <<= 8;
			readByteFromInputBuffer(&rxbyte, &charIdx);
			tmp = tmp|rxbyte;
			i ++;
			len --;
		}
		externalD [n_32b_int] = tmp;
	}
	i = 0;
	tmp = 0;
	while (len > 0) {
		tmp <<= 8;
		readByteFromInputBuffer(&rxbyte, &charIdx);
		tmp = tmp|rxbyte;
		i ++;
		len --;
		if ( i == 4 ) {
			i = 0;
			externalD [n_32b_int-1] = tmp;
			//n_32b_idx ++;
			n_32b_int --;
		}
	}
}

void rsa_sfm_send_hardcoded_key() {
	int i;
	int len = max_digits_of_input_sfm();
	send_char((len*4) >> 8 & 0xff);
	send_char((len*4) >> 0 & 0xff);
	for(i = len - 1 ; i > -1; i --) {
		send_char(rsa_sfm_priv_key.D[i] >> 24 & 0xff);
		send_char(rsa_sfm_priv_key.D[i] >> 16 & 0xff);
		send_char(rsa_sfm_priv_key.D[i] >>  8 & 0xff);
		send_char(rsa_sfm_priv_key.D[i] >>  0 & 0xff);
	}
}

void rsa_sfm_set_key_generation_method(uint8_t method) {
	switch (method) {
			case (KEY_PASSED_TO_THE_TARGET):
			case (KEY_HARDCODED_ON_TARGET):
				keyGenerationMethod = method;
			break;
			// The RANDOM_MASKING_ON_TARGET generation method is currently not used as it's not fully supported and tested
			default:
				// Leave unchanged
			break;
	}
}

void rsa_sfm_set_implementation_method(uint8_t method) {
	switch (method) {
			case (RSA_SFM_IMPLEMENTATION_SIMPLE_SQM):
			case (RSA_SFM_IMPLEMENTATION_SAFE_SQM_XOR):
				implementationType = method;
			break;
			default:
				// Leave unchanged
			break;
	}
}

